# t2stack接口说明

<h2><a name="_Toc256000026"></a>1.1 总体设计</h2>
<p>如下表所示，TongTu RivulNET提供文件传输、流传输能力。TongTu RivulNET编译后以so形式被APP集成，用于近场文件、流数据传输。</p>
<table width="529">
<tbody>
<tr>
<td width="22%">
<p>接口类型</p>
</td>
<td width="78%">
<p>说明</p>
</td>
</tr>
<tr>
<td width="22%">
<p>文件传输</p>
</td>
<td width="78%">
<p>用于近场设备之间传输文件，聚焦于高带宽利用率和高吞吐。</p>
</td>
</tr>
<tr>
<td width="22%">
<p>流传输</p>
</td>
<td width="78%">
<p>用于远近场设备之间传输音视频流，聚焦于低时延的流畅播放。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2><a name="_Toc256000027"></a>1.2 文件传输接口</h2>
<h3><a name="_Toc256000028"></a>1.2.1 建立连接</h3>
<h4><a name="_Toc256000029"></a>1.2.1.1 NSTACKX_DFileServer</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileServer</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>创建文件传输服务端</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileServer(struct sockaddr_in *localAddr, socklen_t addrLen, const uint8_t *key, uint32_t keyLen, DFileMsgReceiver msgReceiver);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef void (*DFileMsgReceiver)(int32_t sessionId, DFileMsgType msgType, const DFileMsg *msg);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>/* DFile session message type list. */</p>
<p>typedef enum {</p>
<p>DFILE_ON_CONNECT_SUCCESS = 1,</p>
<p>DFILE_ON_CONNECT_FAIL,</p>
<p>DFILE_ON_FILE_LIST_RECEIVED,</p>
<p>DFILE_ON_FILE_RECEIVE_SUCCESS,</p>
<p>DFILE_ON_FILE_RECEIVE_FAIL,</p>
<p>DFILE_ON_FILE_SEND_SUCCESS,</p>
<p>DFILE_ON_FILE_SEND_FAIL,</p>
<p>DFILE_ON_FATAL_ERROR,</p>
<p>DFILE_ON_SESSION_IN_PROGRESS,</p>
<p>DFILE_ON_TRANS_IN_PROGRESS,</p>
<p>DFILE_ON_SESSION_TRANSFER_RATE,</p>
<p>DFILE_ON_BIND,</p>
<p>DFILE_ON_CLEAR_POLICY_FILE_LIST，</p>
<p>} DFileMsgType;</p>
<p>/*</p>
<p>* DFile session message data. User should fetch corresponding member variable based on message type:</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFileMsgType&nbsp; Member variable</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_CONNECT_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; none</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_CONNECT_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errorCode</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_FILE_LIST_RECEIVED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileList</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_FILE_RECEIVE_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileList and transferUpdate</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_FILE_RECEIVE_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileList, errorCode and transferUpdate. fileList maybe empty, as not all the file names are received.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_FILE_SEND_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileList and transferUpdate</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_FILE_SEND_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileList, errorCode and transferUpdate.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_TRANS_IN_PROGRESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transferUpdate and fileList. Transfer process update of target trans identified by the transId.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_SESSION_IN_PROGRESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transferUpdate. Transfer process update of the whole session.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_FATAL_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errorCode. DFileSession cannot be used any more, and should be destroyed.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_SESSION_TRANSFER_RATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rate.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_BIND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; socket ip and port.</p>
<p>*&nbsp;&nbsp;&nbsp;&nbsp; DFILE_ON_CLEAR_POLICY_FILE_LIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileList</p>
<p>* It's invalid when for other message types.</p>
<p>*/</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef struct {</p>
<p>struct {</p>
<p>const char **files;</p>
<p>uint32_t fileNum;</p>
<p>uint16_t transId;</p>
<p>char *userData;</p>
<p>} fileList;</p>
<p>struct {</p>
<p>uint32_t fileNum;</p>
<p>const DFileFileInfo *fileInfo;</p>
<p>} clearPolicyFileList;</p>
<p>struct {</p>
<p>uint16_t transId;</p>
<p>uint64_t totalBytes;</p>
<p>uint64_t bytesTransferred;</p>
<p>} transferUpdate;</p>
<p>int32_t errorCode;</p>
<p>uint32_t rate;</p>
<p>struct sockaddr_in sockAddr[NSTACKX_MULTI_PATH_NUM];</p>
<p>} DFileMsg;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>localAddr</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>服务端监听的地址和端口</p>
</td>
</tr>
<tr>
<td width="25%">
<p>addrLen</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>localAddr的长度</p>
</td>
</tr>
<tr>
<td width="25%">
<p>key</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>文件内容传输支持加解密，key为传递进来的密钥。key可以为NULL。约束见下文。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>keyLen</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>上述key的长度，为0或者16或者32。约束见下文。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>msgReceiver</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>回调函数，用于TongTu RivulNET通过回调的方式反馈文件传输进度、发送成功或失败及其它事件等信息。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>大于0的sessionId</p>
</td>
<td width="25%">
<p>成功时返回sessionId</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>1.由调用者保证localAddr内IP地址和端口的正确性，保证addrLen长度的正确性，不正确的地址和长度对TongTu RivulNET的影响是未定义的。</p>
<p>2.由调用者保证key的地址有效，保证keyLen长度的内存可访问，不正确的参数会导致TongTu RivulNET内存访问错误。key为NULL、keyLen为0也是有效的参数，表示不设置密钥。</p>
<p>3.由调用者保证msgReceiver为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>4.文件传输成功与否优先由 DFILE_ON_FILE_SEND_SUCCESS （发送端）和 DFILE_ON_FILE_RECEIVE_SUCCESS（接收端）回调保证。</p>
<p>若发送端在上述回调成功后收到DFILE_ON_FATAL_ERROR回调，可以忽略，此时语义为链路断开或其他异常，但文件已传输成功</p>
<p>5.如果keyLen=0，表示不使用加密，由上层保证文件的完整性和机密性；如果keyLen=16，适用于AES-GCM算法，即当前DFile使用的算法；keyLen=32，作为保留的对其他加密算法的扩展。</p>
<p>6.当key为NULL时，因不校验传输内容，存在攻击者向Server端传输文件的风险，为保持兼容性无法去除该功能，建议上层使用加密方式。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000030"></a>1.2.1.2 NSTACKX_DFileClient</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileClient</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>创建文件传输客户端，连接到服务端。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileClient(struct sockaddr_in *srvAddr, socklen_t addrLen, const uint8_t *key, uint32_t keyLen, DFileMsgReceiver msgReceiver);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>srvAddr</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>服务端监听的地址和端口</p>
</td>
</tr>
<tr>
<td width="25%">
<p>addrLen</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>srvAddr的长度</p>
</td>
</tr>
<tr>
<td width="25%">
<p>key</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>文件内容传输支持加解密，key为传递进来的密钥。key可以为NULL。客户端和服务端的key必须完全一样。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>keyLen</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>上述key的长度，为0或者16或者32。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>msgReceiver</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>回调函数，用于TongTu RivulNET通过回调的方式反馈文件传输进度、发送成功或失败及其它事件等信息。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>大于0的sessionId</p>
</td>
<td width="25%">
<p>成功时返回sessionId</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>1.由调用者保证srvAddr内IP地址和端口的正确性，保证addrLen长度的正确性，不正确的地址和长度对TongTu RivulNET的影响是未定义的。</p>
<p>2.由调用者保证key的地址有效，保证keyLen长度的内存可访问，不正确的参数会导致TongTu RivulNET内存访问错误。key为NULL、keyLen为0也是有效的参数，表示不设置密钥。</p>
<p>3.由调用者保证msgReceiver为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>4.文件传输成功与否优先由 DFILE_ON_FILE_SEND_SUCCESS （发送端）和 DFILE_ON_FILE_RECEIVE_SUCCESS（接收端）回调保证。</p>
<p>若发送端在上述回调成功后收到DFILE_ON_FATAL_ERROR回调，可以忽略，此时语义为链路断开或其他异常，但文件已传输成功</p>
<p>5.如果keyLen=0，表示不使用加密，由上层保证文件的完整性和机密性；如果keyLen=16，适用于AES-GCM算法，即当前DFile使用的算法；keyLen=32，作为保留的对其他加密算法的扩展。</p>
<p>6.当key为NULL时，因不校验传输内容，存在攻击者向Server端传输文件的风险，为保持兼容性无法去除该功能，建议上层使用加密方式。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000031"></a>1.2.1.3 NSTACKX_DFileClientWithTargetDev</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileClientWithTargetDev</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>功能与NSTACKX_DfileClient相同，只是增加了一个参数，用于指定客户端使用的接口名称。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileClientWithTargetDev(NSTACKX_SessionPara *sessionPara);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef struct {</p>
<p>struct sockaddr_in *addr;</p>
<p>socklen_t addrLen;</p>
<p>const uint8_t *key;</p>
<p>uint32_t keyLen;</p>
<p>DFileMsgReceiver msgReceiver;</p>
<p>const char *localInterfaceName;</p>
<p>} NSTACKX_SessionPara;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>addr</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>服务端监听的地址和端口</p>
</td>
</tr>
<tr>
<td width="25%">
<p>addrLen</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>addr的长度</p>
</td>
</tr>
<tr>
<td width="25%">
<p>key</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>文件传输支持加解密，key为传递进来的密钥。key可以为NULL。客户端和服务端的key必须完全一样。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>keyLen</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>上述key的长度，为0或者16或者32。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>msgReceiver</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>回调函数，用于TongTu RivulNET通过回调的方式反馈文件传输进度、发送成功或失败及其它事件等信息。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>localInterfaceName</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>客户端绑定的接口名称。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>大于0的sessionId</p>
</td>
<td width="25%">
<p>成功时返回sessionId</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>由调用者保证sessionPara内所有参数的合法性和有效性，无效或者非法的参数导致的结果是未定义的。key为NULL、keyLen为0也是有效的参数，表示不设置密钥。</p>
<p>localInterfaceName：如果为NULL，则会尝试去绑定与addr同一子网的接口，但是这可能出现未定义的行为；如果不是NULL，则需要传入真实存在的接口名，如果传入不存在的网卡名，会bind网卡失败，但创建client成功，后续通信正常，符合设计预期。</p>
<p>如果keyLen=0，表示不使用加密，由上层保证文件的完整性和机密性；如果keyLen=16，适用于AES-GCM算法，即当前DFile使用的算法；keyLen=32，作为保留的对其他加密算法的扩展。</p>
<p>当key为NULL时，因不校验传输内容，存在攻击者向Server端传输文件的风险，为保持兼容性无法去除该功能，建议上层使用加密方式。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000034"></a>1.2.1.4 NSTACKX_DFileClose</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileClose</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>关闭文件传输会话实例。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文Server或者Client函数创建了文件传输会话实例。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>void NSTACKX_DFileClose(int32_t sessionId);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>上文函数返回的sessionId。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>void</p>
</td>
<td colspan="2" width="50%">
<p>无</p>
</td>
<td width="25%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>1. 由使用者保证传输成功后，客户端早于服务端关闭。否则客户端可能收到DFILE_ON_FATAL_ERROR，代表链路断开。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3><a name="_Toc256000038"></a>1.2.2 传输文件</h3>
<h4><a name="_Toc256000039"></a>1.2.2.1 NSTACKX_DFileSendFiles</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSendFiles</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>客户端发送文件</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文Client函数创建了连接</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSendFiles(int32_t sessionId, const char *files[], uint32_t fileNum, const char *userData);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>Client函数返回的sessionId</p>
</td>
</tr>
<tr>
<td width="25%">
<p>files</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>待传输的文件列表</p>
</td>
</tr>
<tr>
<td width="25%">
<p>fileNum</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>files中文件的个数</p>
</td>
</tr>
<tr>
<td width="25%">
<p>userData</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>可携带传输到接收端的用户数据</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>1.调用者需保证files与fileNum的正确对应，错误的参数导致的后果是未定义的。</p>
<p>2.调用者需保证files里面文件路径的正确性。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000040"></a>1.2.2.2 NSTACKX_DFileSendFilesWithRemotePath</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSendFilesWithRemotePath</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>客户端发送文件，同时指定接收端存放文件的位置。存放位置是一个相对路径，由服务端指定一个根路径之后，在此根路径下根据相对路径存放接收的文件。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文Client函数创建了连接</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSendFilesWithRemotePath(int32_t sessionId, const char *files[], const char *remotePath[], uint32_t fileNum, const char *userData);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>Client函数返回的sessionId</p>
</td>
</tr>
<tr>
<td width="25%">
<p>files</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>待传输的文件列表</p>
</td>
</tr>
<tr>
<td width="25%">
<p>remotePath</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>接收端存放文件的相对位置，与files一一对应</p>
</td>
</tr>
<tr>
<td width="25%">
<p>fileNum</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>files中文件的个数</p>
</td>
</tr>
<tr>
<td width="25%">
<p>userData</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>可携带传输到接收端的用户数据</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>1.由调用者保证files与fileNum的正确对应，错误的参数导致的后果是未定义的。</p>
<p>2.由调用者保证files里面文件路径的正确性，由于TongTu RivulNET与调用者处于同一进程，TongTu RivulNET不再额外对文件路径进行有效性和权限检查。</p>
<p>3.由调用者保证remotePath的有效性和正确性，TongTu RivulNET不再额外对该路径进行有效性和权限检查。</p>
<p>4.TongTu RivulNET本身不检查并限制文件大小，由调用者保证文件大小不会超出系统限制。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000041"></a>1.2.2.3 NSTACKX_DFileSendFilesWithRemotePathAndType</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSendFilesWithRemotePathAndType</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>客户端发送文件，同时指定接收端存放文件的位置。存放位置是一个相对路径，由服务端指定一个根路径之后，在此根路径下根据相对路径存放接收的文件。该接口可以指定接收文件类型，如视频、图片、应用等，用于克隆传输接口。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文Client函数创建了连接</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSendFilesWithRemotePathAndType(int32_t sessionId, NSTACKX_FilesInfo *filesInfo);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef struct {</p>
<p>const char *files[NSTACKX_DFILE_MAX_FILE_NUM];</p>
<p>const char *remotePath[NSTACKX_DFILE_MAX_FILE_NUM];</p>
<p>uint32_t fileNum;</p>
<p>const char *userData;</p>
<p>uint16_t pathType;</p>
<p>uint8_t tarFlag : 1;</p>
<p>uint8_t smallFlag : 1;</p>
<p>uint8_t unuse : 6;</p>
<p>} NSTACKX_FilesInfo;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>Client函数返回的sessionId</p>
</td>
</tr>
<tr>
<td width="25%">
<p>files</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>待传输的文件列表</p>
</td>
</tr>
<tr>
<td width="25%">
<p>remotePath</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>接收端存放文件的相对位置，与files一一对应</p>
</td>
</tr>
<tr>
<td width="25%">
<p>fileNum</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>files中文件的个数</p>
</td>
</tr>
<tr>
<td width="25%">
<p>userData</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>可携带传输到接收端的用户数据</p>
</td>
</tr>
<tr>
<td width="25%">
<p>pathType</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>文件类型</p>
</td>
</tr>
<tr>
<td width="25%">
<p>tarFlag</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>是否将文件打包传输（当前版本不支持该特性）</p>
</td>
</tr>
<tr>
<td width="25%">
<p>smallflag</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>是否为小文件（当前版本不支持该特性）</p>
</td>
</tr>
<tr>
<td width="25%">
<p>unuse</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>未使用</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>1.由调用者保证filesInfo内files与fileNum的正确对应，错误的参数导致的后果是未定义的。</p>
<p>2.由调用者保证filesInfo内files里面文件路径的正确性，由于TongTu RivulNET与调用者处于同一进程，TongTu RivulNET不再额外对文件路径进行有效性和权限检查。</p>
<p>3.由调用者保证filesInfo内remotePath的有效性和正确性，由于TongTu RivulNET与调用者处于同一进程，TongTu RivulNET不再额外对该路径进行有效性和权限检查。</p>
<p>4.TongTu RivulNET本身不检查并限制文件大小，由调用者保证文件大小不会超出系统限制。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000042"></a>1.2.2.4 NSTACKX_DFileSetStoragePath</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSetStoragePath</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接收端设置接收文件存储根路径</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文server函数创建了服务端</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSetStoragePath(int32_t sessionId, const char *path);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>Server函数返回的sessionId</p>
</td>
</tr>
<tr>
<td width="25%">
<p>path</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>接收文件的存储根路径</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>由调用者保证path的有效性和正确性，由于TongTu RivulNET与调用者处于同一进程，TongTu RivulNET不再额外对该路径进行有效性和权限检查。</p>
<p>不可多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000043"></a>1.2.2.5 NSTACKX_DFileSetRenameHook</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSetRenameHook</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>Server侧使用该接口设置一个回调函数，用于对相同路径相同文件名的文件进行重命名，如果没有重命名，文件将会被覆盖。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文server函数创建了服务端</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSetRenameHook(int32_t sessionId, OnDFileRenameFile onRenameFile);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef void (*OnDFileRenameFile)(DFileRenamePara *renamePara);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>Server函数返回的sessionId</p>
</td>
</tr>
<tr>
<td width="25%">
<p>onRenameFile</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>重命名回调处理函数</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>由调用者保证onRenameFile为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>不可多线程设置。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000044"></a>1.2.2.6 NSTACKX_DFileSetStoragePathList</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSetStoragePathList</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>针对不同类型文件，设置不同的存储根路径。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>已通过上文server函数创建了服务端</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSetStoragePathList(int32_t sessionId, const char *path[], const uint16_t *pathType, uint16_t pathNum);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>sessionId</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>Server函数返回的sessionId</p>
</td>
</tr>
<tr>
<td width="25%">
<p>path</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>文件的存储根路径</p>
</td>
</tr>
<tr>
<td width="25%">
<p>pathType</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>根路径对应的文件类型</p>
</td>
</tr>
<tr>
<td width="25%">
<p>pathNum</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>根路径数量，也就是数组path和pathType的长度。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>由调用者保证path和pathType的有效性和正确性，由于TongTu RivulNET与调用者处于同一进程，TongTu RivulNET不再额外对该路径进行有效性和权限检查。</p>
<p>不可多线程设置。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000045"></a>1.2.3 设置日志函数</h3>
<h4><a name="_Toc256000046"></a>1.2.3.1 NSTACKX_DFileRegisterLog</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileRegisterLog</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>设置外部使用的日志函数</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>在调用上文的接口创建服务端和客户端之前调用本接口。目前只支持Windows系统。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileRegisterLog(DFileLogImpl logImpl);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef void (*DFileLogImpl)(const char *tag, uint32_t level, const char *format, va_list args);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>DFileLogImpl</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>外部提供的日志实现函数</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>小于0的错误码</p>
</td>
<td width="25%">
<p>代表失败的错误码</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>等于0</p>
</td>
<td width="25%">
<p>代表该接口调用成功</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用者需要保证传入的函数指针的有效性和功能正确性。外部实现的日志函数应具有printf语义，能正确处理可变参数。</p>
<p>不可多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000047"></a>1.2.3.2 NSTACKX_DFileRegisterLogCallback</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileRegisterLogCallback&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>设置外部使用的日志函数&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>在调用上文的接口创建服务端和客户端之前调用本接口。&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileRegisterLogCallback(DFileLogCallback userLogCallback);&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef void (*DFileLogCallback)(const char *moduleName, uint32_t logLevel, const char *format, ...);&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：&crarr;</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称&crarr;</p>
</td>
<td width="25%">
<p>方向&crarr;</p>
</td>
<td colspan="2" width="50%">
<p>描述&crarr;</p>
</td>
</tr>
<tr>
<td width="25%">
<p>DFileLogCallback&crarr;</p>
</td>
<td width="25%">
<p>[IN]&crarr;</p>
</td>
<td colspan="2" width="50%">
<p>外部提供的日志实现函数&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：&crarr;</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型&crarr;</p>
</td>
<td colspan="2" width="50%">
<p>返回值&crarr;</p>
</td>
<td width="25%">
<p>描述&crarr;</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t&crarr;</p>
</td>
<td colspan="2" width="50%">
<p>小于0的错误码&crarr;</p>
</td>
<td width="25%">
<p>代表失败的错误码&crarr;</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>等于0&crarr;</p>
</td>
<td width="25%">
<p>代表该接口调用成功&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：&crarr;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用者需要保证传入的函数指针的有效性和功能正确性。外部实现的日志函数应具有printf语义，能正确处理可变参数。&crarr;</p>
<p>不可多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000048"></a>1.2.3.3 NSTACKX_DFileRegisterDefaultLog</h4>
<table width="529">
<tbody>
<tr>
<td width="100%">
<p>接口名称：&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>NSTACKX_DFileRegisterDefaultLog</p>
</td>
</tr>
<tr>
<td width="100%">
<p>描述：&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>设置使用默认的日志函数&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>调用条件：&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>在调用上文的接口创建服务端和客户端之前调用本接口。&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>接口原型：&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>void NSTACKX_DFileRegisterDefaultLog(void);&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>接口使用约束：&crarr;</p>
</td>
</tr>
<tr>
<td width="100%">
<p>&crarr;不可多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000049"></a>1.2.4 获取和设置支持的功能</h3>
<h4><a name="_Toc256000050"></a>1.2.4.1 NSTACKX_DFileGetCapabilities</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileGetCapabilities</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>获取DFile支持的功能</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>uint32_t NSTACKX_DFileGetCapabilities(void);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>无参数</p>
</td>
<td width="25%">
<p>&nbsp;</p>
</td>
<td colspan="2" width="50%">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>uint32_t</p>
</td>
<td colspan="2" width="50%">
<p>32位无符号的比特位集合</p>
</td>
<td width="25%">
<p>每一个比特位代表了DFile支持的一个具体功能，多个不同功能采用位或的方式组成集合</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>第一次调用该接口时，返回在当前系统上DFile支持的全部功能集合；第二次及之后的调用，将返回当前设置的功能集合。在调用NSTACKX_DFileSetCapabilities()之后再调用本接口（无论第几次）都会返回当前开启的功能集合。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000051"></a>1.2.4.2 NSTACKX_DFileSetCapabilities</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSetCapabilities</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>设置DFile需要开启的功能</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileSetCapabilities(uint32_t capabilities, uint32_t value);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>capabilities</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>需要开启的功能的比特位集合</p>
</td>
</tr>
<tr>
<td width="25%">
<p>value</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>某些功能需要额外的参数，比如WLAN_CATEGORY功能，需要使用value传递额外参数进行配置</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>设置成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>1</p>
</td>
<td width="25%">
<p>设置失败</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>该接口用于设置需要开启的功能，但该功能是否受支持由DFile通过探测决定，不保证设置的功能一定能启用。设置后如果要查询是否开启成功，需要使用上面的NSTACKX_DFileGetCapabilities()接口。</p>
<p>不可多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4>1.2.4.3 NSTACKX_DFileSetSessionOpt</h4>
<table width="529">
<tbody>
<tr>
<td colspan="3" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>NSTACKX_DFileSetSessionOpt</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>客户端下发session配置</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>客户端已创建成功</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>NSTACKX_EXPORT int32_t NSTACKX_DFileSetSessionOpt(int32_t sessionId, const DFileOpt *opt);</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>typedef struct {</p>
<p>DFileOptType optType;</p>
<p>uint32_t valLen; /* length of value */</p>
<p>uint64_t value; /* the option value, could be a poiniter */</p>
<p>} DFileOpt;</p>
<p>typedef enum {</p>
<p>/* the priority of socket, value is same as IP_TOS, valLen is sizeof(uint8_t) */</p>
<p>OPT_TYPE_SOCK_PRIO,</p>
<p>OPT_TYPE_BUTT</p>
<p>} DFileOptType;</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="33%">
<p>名称</p>
</td>
<td width="33%">
<p>方向</p>
</td>
<td width="33%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="33%">
<p>sessionId</p>
</td>
<td width="33%">
<p>[IN]</p>
</td>
<td width="33%">
<p>客户端会话ID</p>
</td>
</tr>
<tr>
<td width="33%">
<p>opt</p>
</td>
<td width="33%">
<p>[IN]</p>
</td>
<td width="33%">
<p>下发的具体配置项，详见DFileOpt结构体</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="33%">
<p>类型</p>
</td>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="33%">
<p>int32_t</p>
</td>
<td width="33%">
<p>0</p>
</td>
<td width="33%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td width="33%">
<p>小于0的错误码</p>
</td>
<td width="33%">
<p>失败时返回错误码</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000056"></a>1.2.4.4 功能位比特列表</h4>
<table width="529">
<tbody>
<tr>
<td width="27%">
<p>功能</p>
</td>
<td width="27%">
<p>比特位</p>
</td>
<td width="45%">
<p>说明</p>
</td>
</tr>
<tr>
<td width="27%">
<p>NSTACKX_CAPS_UDP_GSO</p>
</td>
<td width="27%">
<p>0</p>
</td>
<td width="45%">
<p>UDP GSO功能</p>
</td>
</tr>
<tr>
<td width="27%">
<p>NSTACKX_CAPS_LINK_SEQUENCE</p>
</td>
<td width="27%">
<p>1</p>
</td>
<td width="45%">
<p>Z SEQUENCE功能</p>
</td>
</tr>
<tr>
<td width="27%">
<p>NSTACKX_CAPS_WLAN_CATAGORY</p>
</td>
<td width="27%">
<p>2</p>
</td>
<td width="45%">
<p>WLAN相关功能</p>
</td>
</tr>
<tr>
<td width="27%">
<p>NSTACKX_CAPS_MULTIPATH</p>
</td>
<td width="27%">
<p>3</p>
</td>
<td width="45%">
<p>多径功能</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000057"></a>1.2.5 DFX相关</h3>
<h4><a name="_Toc256000058"></a>1.2.5.1 NSTACKX_DFileDump</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileDump</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>HiDump的调用函数</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>int32_t NSTACKX_DFileDump(uint32_t argc, const char **arg, void *softObj,</p>
<p>DFileDumpFunc dump)</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef void (*DFileDumpFunc)(void *softObj, const char *data, uint32_t len);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>argc</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>字符串指针数组arg的元素个数。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>arg</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>存储命令行参数，需传入一个字符串指针数组，第一个字符串不会被使用，从第二个字符串开始写入命令行参数（例：char *arg[] = {&ldquo;test&rdquo;, &ldquo;-h&rdquo;}）</p>
</td>
</tr>
<tr>
<td width="25%">
<p>softObj</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>调用方需传递给回调函数dump的参数。</p>
</td>
</tr>
<tr>
<td width="25%">
<p>dump</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>调用方提供的回调函数，用于处理Hidump输出的长度为len的字符串data。</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>int32_t</p>
</td>
<td colspan="2" width="50%">
<p>0</p>
</td>
<td width="25%">
<p>调用成功</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>-1</p>
</td>
<td width="25%">
<p>调用失败</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>由调用者确保dump为正确函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>由调用者确保arg和softObj参数的地址有效性，不正确的函数指针会导致不可预料的后果</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000059"></a>1.2.5.2 NSTACKX_DFileSetEventFunc</h4>
<table width="529">
<tbody>
<tr>
<td colspan="4" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>NSTACKX_DFileSetEventFunc</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>设置DFile在事件发生时需要执行的行为</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>无</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>void NSTACKX_DFileSetEventFunc(void *softObj, DFileEventFunc func);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef void (*DFileEventFunc)(void *softObj, const DFileEvent *info);</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>typedef enum {</p>
<p>DFile_EVENT_TYPE_FAULT,</p>
<p>DFile_EVENT_TYPE_STATISTIC,</p>
<p>DFile_EVENT_TYPE_SECURITY,</p>
<p>DFile_EVENT_TYPE_BEHAVIOR,</p>
<p>} DFileEventType;</p>
<p>typedef enum {</p>
<p>DFile_EVENT_LEVEL_CRITICAL,</p>
<p>DFile_EVENT_LEVEL_MINOR,</p>
<p>} DFileEventLevel;</p>
<p>typedef enum {</p>
<p>DFile_PARAM_TYPE_BOOL,</p>
<p>DFile_PARAM_TYPE_UINT8,</p>
<p>DFile_PARAM_TYPE_UINT16,</p>
<p>DFile_PARAM_TYPE_INT32,</p>
<p>DFile_PARAM_TYPE_UINT32,</p>
<p>DFile_PARAM_TYPE_UINT64,</p>
<p>DFile_PARAM_TYPE_FLOAT,</p>
<p>DFile_PARAM_TYPE_DOUBLE,</p>
<p>DFile_PARAM_TYPE_STRING</p>
<p>} DFileEventParamType;</p>
<p>#define DFile_EVENT_NAME_LEN 33</p>
<p>#define DFile_EVENT_TAG_LEN 16</p>
<p>typedef struct {</p>
<p>DFileEventParamType type;</p>
<p>char name[DFile_EVENT_NAME_LEN];</p>
<p>union {</p>
<p>uint8_t u8v;</p>
<p>uint16_t u16v;</p>
<p>int32_t i32v;</p>
<p>uint32_t u32v;</p>
<p>uint64_t u64v;</p>
<p>float f;</p>
<p>double d;</p>
<p>char str[DFile_EVENT_NAME_LEN];</p>
<p>} value;</p>
<p>} DFileEventParam;</p>
<p>typedef struct {</p>
<p>char eventName[DFile_EVENT_NAME_LEN];</p>
<p>DFileEventType type;</p>
<p>DFileEventLevel level;</p>
<p>uint32_t paramNum;</p>
<p>DFileEventParam *params;</p>
<p>} DFileEvent;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>名称</p>
</td>
<td width="25%">
<p>方向</p>
</td>
<td colspan="2" width="50%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="25%">
<p>softObj</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>透明传输参数</p>
</td>
</tr>
<tr>
<td width="25%">
<p>func</p>
</td>
<td width="25%">
<p>[IN]</p>
</td>
<td colspan="2" width="50%">
<p>事件发生时需要执行的行为函数</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="25%">
<p>类型</p>
</td>
<td colspan="2" width="50%">
<p>返回值</p>
</td>
<td width="25%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="25%">
<p>无返回值</p>
</td>
<td colspan="2" width="50%">
<p>&nbsp;</p>
</td>
<td width="25%">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="2" width="50%">
<p>&nbsp;</p>
</td>
<td width="25%">
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="4" width="100%">
<p>使用者将DFileEventFunc类型的函数作为参数输入即可完成事件行为，注意保证参数类型正确。</p>
<p>不可多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000061"></a>1.2.5.3 NSTACKX_DFileSessionGetFileList</h4>
<table width="529">
<tbody>
<tr>
<td colspan="3" width="100%">
<p>接口名称：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>NSTACKX_DFileSessionGetFileList</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>描述：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>触发上报DFILE_ON_CLEAR_POLICY_FILE_LIST事件，携带对应清理策略的文件列表信息</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>调用条件：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>客户端已创建成功</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>接口原型：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>int32_t NSTACKX_DFileSessionGetFileList(int32_t sessionId);</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>参数：</p>
</td>
</tr>
<tr>
<td width="33%">
<p>名称</p>
</td>
<td width="33%">
<p>方向</p>
</td>
<td width="33%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="33%">
<p>sessionId</p>
</td>
<td width="33%">
<p>[IN]</p>
</td>
<td width="33%">
<p>客户端会话ID</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>返回值：</p>
</td>
</tr>
<tr>
<td width="33%">
<p>类型</p>
</td>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>描述</p>
</td>
</tr>
<tr>
<td rowspan="2" width="33%">
<p>int32_t</p>
</td>
<td width="33%">
<p>0</p>
</td>
<td width="33%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td width="33%">
<p>小于0的错误码</p>
</td>
<td width="33%">
<p>失败时返回错误码</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>接口使用约束：</p>
</td>
</tr>
<tr>
<td colspan="3" width="100%">
<p>NA</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3><a name="_Toc256000067"></a>1.2.6 交互流程</h3>

![](figures/File_transfer_processes.png)

<p>建立连接时，客户端可以使用NSTACKX_DFileClient或者NSTACKX_DFileClientWithTargetDev，如果想要建立多通道连接，客户端和服务端可以分别使用NSTACKX_DFileClientMp和NSTACKX_DFileServerMp。</p>
<p>发送文件时，客户端可以使用NSTACKX_DFileSendFiles或者NSTACKX_DFileSendFilesWithRemotePath或者NSTACKX_DFileSendFilesWithRemotePathAndType。服务端可以调用NSTACKX_DFileSetStoragePath或者NSTACKX_DFileSetStoragePathList设置存放文件的路径。</p>
<h3><a name="_Toc256000068"></a>1.2.7 错误码列表</h3>
<table width="529">
<tbody>
<tr>
<td width="44%">
<p>错误码</p>
</td>
<td width="56%">
<p>说明</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EOK 0</p>
</td>
<td width="56%">
<p>操作成功</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EFAILED (-1)</p>
</td>
<td width="56%">
<p>操作失败</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EINVAL (-2)</p>
</td>
<td width="56%">
<p>参数错误</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EINPROGRESS (-3)</p>
</td>
<td width="56%">
<p>正在处理，请勿重复操作</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EBUSY (-4)</p>
</td>
<td width="56%">
<p>系统忙，任务积压</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_ENOMEM (-5)</p>
</td>
<td width="56%">
<p>内存不足</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EEXIST (-6)</p>
</td>
<td width="56%">
<p>文件已存在</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EAGAIN (-7)</p>
</td>
<td width="56%">
<p>操作被中断，请重试</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_ETIMEOUT (-8)</p>
</td>
<td width="56%">
<p>超时</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_OVERFLOW (-9)</p>
</td>
<td width="56%">
<p>超出规格限制</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_NOEXIST (-10)</p>
</td>
<td width="56%">
<p>文件不存在</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EINTR (-11)</p>
</td>
<td width="56%">
<p>系统中断，请重试</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_NOTSUPPORT(-12)</p>
</td>
<td width="56%">
<p>操作不支持</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_PEER_CLOSE (-13)</p>
</td>
<td width="56%">
<p>连接已关闭</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EPERM (-14)</p>
</td>
<td width="56%">
<p>操作不允许，无权限</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_EDQUOT (-15)</p>
</td>
<td width="56%">
<p>超出磁盘配额</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_ENETDOWN (-16)</p>
</td>
<td width="56%">
<p>网络不可用</p>
</td>
</tr>
<tr>
<td width="44%">
<p>#define NSTACKX_ENOENT (-17)</p>
</td>
<td width="56%">
<p>文件或目录不存在</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2><a name="_Toc256000078"></a>1.3 流传输接口</h2>
<p>流传输组件的大多数接口是不支持多线程调用的，具体支持情况，参考各函数使用约束。</p>
<h3><a name="_Toc256000079"></a>1.3.1 初始化接口</h3>
<p>FillP使用之前需要进行初始化</p>
<h4><a name="_Toc256000080"></a>1.3.1.1 FtInit</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtInit();</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This API is used to initialize the VTP/FillP stack.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000081"></a>1.3.1.2 FtDestroy</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>void FtDestroy();&crarr;</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>This API is used to deinitialize the FillP stack.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>None&crarr;</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>None&crarr;</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>None&crarr;</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>None&crarr;</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>调用者须在调用此接口之前显式关闭所有Fillp socket；</p>
<p>此接口将在FillP协议栈销毁完成后返回，可能阻塞较长时间。</p>
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000082"></a>1.3.1.3 FtDestroyNonblock</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型胡</p>
</td>
<td colspan="2" width="80%">
<p>void FtDestroyNonblock();</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This API is use to deinit the fillp stack but not block.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>调用者须在调用此接口之前显式关闭所有Fillp socket；</p>
<p>此接口返回代表已通知Fillp协议栈销毁自身，不代表销毁已经完成。</p>
</td>
</tr>
<tr>
<td width="20%">
<p>注意事项</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000083"></a>1.3.2 socket接口</h3>
<h4><a name="_Toc256000084"></a>1.3.2.1 FtSocket</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>FILLP_INT FtSocket(FILLP_INT domain, FILLP_INT type, FILLP_INT protocol);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>Creates an endpoint for communication and returns a descriptor. The usage is the same as the socket function of the TCP socket.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>domain</p>
</td>
<td width="33%">
<p>Indicates the domain to communicate.&crarr;</p>
</td>
</tr>
<tr>
<td width="33%">
<p>type</p>
</td>
<td width="33%">
<p>Indicates the type of connection.&crarr;</p>
</td>
</tr>
<tr>
<td width="33%">
<p>protocol</p>
</td>
<td width="33%">
<p>Indicates the type of protocol used.&crarr;</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_INT</p>
</td>
<td width="33%">
<p>On success, a file descriptor for the new socket is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000085"></a>1.3.2.2 FtBind</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtBind(FILLP_INT fd, FILLP_CONST struct sockaddr *name, FILLP_UINT32 nameLen);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This interface is used to bind to a socket created by the FtSocket() API. The usage is the same as the bind function of the TCP socket.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Specifies a descriptor identifying an unbound socket created by the FtSocket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>name</p>
</td>
<td width="40%">
<p>Specifies a pointer to a SockAddr structure of the local address to assign to the bound socket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>nameLen</p>
</td>
<td width="40%">
<p>Specifies the length, in bytes, of the value pointed to by the name parameter.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证name的地址有效，同时保证nameLen的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>name为NULL、nameLen为0是有效的参数。</p>
<p>不支持name的内容为INADDR_ANY 。</p>
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000086"></a>1.3.2.3 FtListen</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtListen(FILLP_INT fd, FILLP_INT backLog);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Listens for connections on a socket. This function is the as same as the listen function of the TCP socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="20%">
<p>&nbsp;</p>
</td>
<td width="40%">
<p>backLog</p>
</td>
<td width="40%">
<p>Defines the maximum length to which the queue of pending connections for fd can grow.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000087"></a>1.3.2.4 FtAccept</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>FILLP_INT FtAccept(FILLP_INT fd, struct sockaddr *addr, socklen_t *addrLen);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>Accept a connection on a socket. This is same as the accept function of the TCP socket.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>fd</p>
</td>
<td width="33%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>addrLen</p>
</td>
<td width="33%">
<p>Indicates the length of the SockAddr structure.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>addr</p>
</td>
<td width="33%">
<p>Indicates a pointer to a SockAddr structure that contains the address of the peer socket.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_INT</p>
</td>
<td width="33%">
<p>On success, return a file descriptor for the accepted socket.</p>
<p>On error, -1 is returned, errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>由调用者保证addr、addrLen的地址有效，同时保证*addrLen长度的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>addr为NULL、addrLen为NULL是有效的参数。</p>
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000088"></a>1.3.2.5 FtConnect</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtConnect(FILLP_INT fd, FILLP_CONST FILLP_SOCKADDR *name, socklen_t nameLen);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Initiates a connection on a socket. This is same as the TCP connect function. If the socket is a non-block and there is a non-block error on the socket during FtConnect function, the API returns -1. You can retrieve the last error number of the socket by calling the FtGetErrno API.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>name</p>
</td>
<td width="40%">
<p>Indicates the socket type, which must be of type SOCK_STREAM.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>nameLen</p>
</td>
<td width="40%">
<p>Specifies the length, in bytes, of the value pointed to by the name parameter.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证name的地址有效，同时保证nameLen的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000089"></a>1.3.2.6 FtSend</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtSend(FILLP_INT fd, FILLP_CONST void *data, size_t size, FILLP_INT flag);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Sends a message on a socket. This function is the same as the send function of the TCP socket. If the socket is set as NON-Block, and if the non-block error happens, the the API returns -1 and the error number is set as ERR_EAGAIN. You can retrieve the last error number of the socket by calling the FtGetErrno() API.</p>
</td>
</tr>
<tr>
<td rowspan="4" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates the socket created by FtSocket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>data</p>
</td>
<td width="40%">
<p>Indicates a data pointer</p>
</td>
</tr>
<tr>
<td width="40%">
<p>size</p>
</td>
<td width="40%">
<p>Indicates the size of the message.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>flag</p>
</td>
<td width="40%">
<p>Indicates the status.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, return the number of bytes sent.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证data的地址有效，同时保证size的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000090"></a>1.3.2.7 FtSendFrame</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtSendFrame(FILLP_INT fd, FILLP_CONST void *data, size_t size, FILLP_INT flag,</p>
<p>FILLP_CONST struct FrameInfo *frame);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Sends a video frame on a socket. This function is is same with FtSend except the argument 'frame'. If the socket is set as NON-Block, and if the non-block error happens, the the API returns -1 and the error number is set as ERR_EAGAIN. You can retrieve the last error number of the socket by calling the FtGetErrno() API.</p>
</td>
</tr>
<tr>
<td rowspan="5" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates the socket created by FtSocket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>data</p>
</td>
<td width="40%">
<p>Indicates a data pointer</p>
</td>
</tr>
<tr>
<td width="40%">
<p>size</p>
</td>
<td width="40%">
<p>Indicates the size of the message.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>flag</p>
</td>
<td width="40%">
<p>Indicates the status.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>frame</p>
</td>
<td width="40%">
<p>Indicates frame infomation(including the frame type I or P, etc.) of the video/audio frame.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, return the number of bytes sent.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证data、frame的地址有效，同时保证size的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>本接口仅供终端投屏抗干扰场景使用。struct FrameInfo与终端当前定义保持一致：</p>
<p>struct FrameInfo {</p>
<p>FILLP_INT frameType;</p>
<p>FILLP_INT seqNum;</p>
<p>FILLP_INT subSeqNum;</p>
<p>FILLP_INT level;</p>
<p>FILLP_SLONG timestamp;</p>
<p>FILLP_UINT32 bitMap;</p>
<p>};</p>
<p>各字段含义如下：</p>
<table width="529">
<tbody>
<tr>
<td width="17%">
<p>成员</p>
</td>
<td width="21%">
<p>类型</p>
</td>
<td width="62%">
<p>描述</p>
</td>
</tr>
<tr>
<td width="17%">
<p>frameType</p>
</td>
<td width="21%">
<p>FILLP_INT</p>
</td>
<td width="62%">
<p>视频帧类型，取值如下：</p>
<p>NONE = 0, 非视频帧</p>
<p>VIDEO_I = 1, I帧</p>
<p>VIDEO _P = 2, P帧</p>
</td>
</tr>
<tr>
<td width="17%">
<p>seqNum</p>
</td>
<td width="21%">
<p>FILLP_INT</p>
</td>
<td width="62%">
<p>帧序号，同一个帧的不同分片或不同层次帧序号相同。序号从0开始递增，最大值2147483647</p>
</td>
</tr>
<tr>
<td width="17%">
<p>subSeqNum</p>
</td>
<td width="21%">
<p>FILLP_INT</p>
</td>
<td width="62%">
<p>当前帧切片序号，同一个帧的不同切片从0开始编号，并依次递增</p>
</td>
</tr>
<tr>
<td width="17%">
<p>level</p>
</td>
<td width="21%">
<p>FILLP_INT</p>
</td>
<td width="62%">
<p>分层编码所属层次</p>
</td>
</tr>
<tr>
<td width="17%">
<p>timestamp</p>
</td>
<td width="21%">
<p>FILLP_SLONG</p>
</td>
<td width="62%">
<p>时间戳，未使用</p>
</td>
</tr>
<tr>
<td width="17%">
<p>bitMap</p>
</td>
<td width="21%">
<p>FILLP_UINT32</p>
</td>
<td width="62%">
<p>标记位，目前支持以下标记：</p>
<p>FRAME_INFO_BITMAP_SLICE_END（0x00000001），标记是否是视频帧的最后一个切片</p>
<p>FRAME_INFO_BITMAP_FRAME_END（0x00000002），标记当前发送的数据块（即RTP包）是否是当前帧最后一个数据块</p>
<p>FRAME_INFO_BITMAP_LAYER_END（0x00000004），标记当前发送的数据块（即RTP包）是否是当前帧当前层次的最后一个数据块</p>
<p>FRAME_INFO_BITMAP_EXT （0x80000000），使用扩展的frame info</p>
<p>注：1)FRAME_INFO_BITMAP_FRAME_END标记位设置时，其他两个标记位可以不用设置</p>
<p>2) FRAME_INFO_BITMAP_LAYER_END设置时，FRAME_INFO_BITMAP_SLICE_END可以不用设置</p>
<p>3）FtSendFrame接口的frame参数，不能置位FRAME_INFO_BITMAP_EXT位，如果置位，请使用FtSendFrameExt接口</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000091"></a>1.3.2.8 FtRecv</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtRecv(FILLP_INT fd, void *mem, size_t len, FILLP_INT flag);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This is an interface for the user to receive messages from a socket. This is same as the TCP receive function. If the socket is a non-block and there is non-block error on the socket during FtConnect(), then the API will return -1. You can retrieve the last error number of the socket by calling the FtGetErrno API.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="40%">
<p>len</p>
</td>
<td width="40%">
<p>Indicates the length, in bytes, of the buffer pointed by the buffer argument.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>flag</p>
</td>
<td width="40%">
<p>Indicates the flag.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>mem</p>
</td>
<td width="40%">
<p>Indicates a pointer to the buffer where the message is stored.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, the number of bytes received.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证mem的地址有效，同时保证len的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000092"></a>1.3.2.9 FtReadv</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtReadv(FILLP_INT fd, const struct iovec *iov, FILLP_INT iovCount);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This is an interface for the user to recv a message on a socket.</p>
<p>If the socket is set as NON-Block and if the non-block error happens then the API returns -1.</p>
<p>The Last error number of the socket can be retrieved by calling the API FtGetErrno.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="40%">
<p>iovCount</p>
</td>
<td width="40%">
<p>Buffer count of data described by iov.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>iov</p>
</td>
<td width="40%">
<p>A pointer which points to an array of iovec structures.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, the number of bytes read.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证iov的地址有效，同时保证iovCount正确。不正确的参数会导致内存访问错误。</p>
<p>该接口仅适用于非windows平台，且需要开启FILLP_MMSG_SUPPORT宏才能使用。</p>
<p>支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000093"></a>1.3.2.10 FtWritev</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtWritev(FILLP_INT fd, const struct iovec *iov, FILLP_INT iovCount);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This is an interface for the user to send a message on a socket.</p>
<p>If the socket is set as NON-Block and if the non-block error happens then the API returns -1.</p>
<p>The Last error number of the socket can be retrieved by calling the API FtGetErrno.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="40%">
<p>iov</p>
</td>
<td width="40%">
<p>A pointer which points to an array of iovec structures.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>iovCount</p>
</td>
<td width="40%">
<p>Buffer count of data described by iov.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, return the number of bytes written.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证iov的地址有效，同时保证iovCount正确。不正确的参数会导致内存访问错误。</p>
<p>该接口仅适用于非windows平台，且需要开启FILLP_MMSG_SUPPORT宏才能使用。</p>
<p>支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000094"></a>1.3.2.11 FtClose</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtClose(FILLP_INT fd);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Closes the socket connection and releases all associated resources. This API is same as the close function of TCP socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>FtClose支持与FtSend、FtSendFrame、FtSendFrameExt、FtWritev、FtRecv、FtReadv接口多线程调用，但FtClose接口本身不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000095"></a>1.3.2.12 FtShutDown</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtShutDown(FILLP_INT fd, FILLP_INT how);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Initiates a graceful closure of the socket connection from initiating side (uni-directional).</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket().</p>
</td>
</tr>
<tr>
<td width="40%">
<p>how</p>
</td>
<td width="40%">
<p>If how is SHUT_RD, further receptions will be disallowed.&nbsp; If how is SHUT_WR, further transmissions will be disallowed. If how is SHUT_RDWR, further receptions and transmissions will be disallowed.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>FtShutDown支持与FtSend、FtSendFrame、FtSendFrameExt、FtWritev、FtRecv、FtReadv接口多线程调用，但FtShutDown接口本身不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000097"></a>1.3.3 epoll接口</h3>
<h4><a name="_Toc256000098"></a>1.3.3.1 FtEpollCreate</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtEpollCreate();</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This API is used to open an epoll file descriptor.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, return a file descriptor.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000099"></a>1.3.3.2 FtEpollCreateLinux</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtEpollCreateLinux(FILLP_INT epNum);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This API is used to open an linux epoll file descriptor.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>epNum</p>
</td>
<td width="40%">
<p>Unused,should &gt; 0.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, return a file descriptor.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000100"></a>1.3.3.3 FtEpollCtl</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtEpollCtl(FILLP_INT epFd, FILLP_INT op, FILLP_INT fd,</p>
<p>FILLP_CONST struct SpungeEpollEvent *event);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This API indicates the control interface for epoll file descriptor.</p>
</td>
</tr>
<tr>
<td rowspan="4" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>epFd</p>
</td>
<td width="40%">
<p>Indicates a file descriptor on which the operation is performed.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>op</p>
</td>
<td width="40%">
<p>Indicates an operation which needs to be performed.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a file descriptor.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>event</p>
</td>
<td width="40%">
<p>Indicates an object linked to the file descriptor.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证event的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000101"></a>1.3.3.4 FtEpollWait</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtEpollWait(FILLP_INT epFd, struct SpungeEpollEvent *events,</p>
<p>FILLP_INT maxEvents, FILLP_INT timeout);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function indicates wait for an I/O event on an epoll file descriptor.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>epFd</p>
</td>
<td width="40%">
<p>Indicates a file descriptor on which the operation is performed.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>maxEvents</p>
</td>
<td width="40%">
<p>Indicates the maximum number of events.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>timeout</p>
</td>
<td width="40%">
<p>Indicates the maximum timeout value, in milliseconds.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>events</p>
</td>
<td width="40%">
<p>Indicates the memory area pointed to the events, containing the events that will be available for the caller.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, return the number of file descriptors ready for the requested I/O, or zero if no file descriptor became ready during the requested timeout milliseconds.</p>
<p>On failure, return -1 and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证events的地址有效，同时保证maxEvents正确。不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000102"></a>1.3.4 control接口</h3>
<h4><a name="_Toc256000103"></a>1.3.4.1 FtGetSockOpt</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtGetSockOpt(FILLP_INT fd, FILLP_INT level, FILLP_INT optName,</p>
<p>void *optValue, FILLP_INT *optLen);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the Fillp Adapter to get socket options.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="47%">
<p>fd</p>
</td>
<td width="33%">
<p>Indicates a socket created by FtSocket.</p>
</td>
</tr>
<tr>
<td width="47%">
<p>level</p>
</td>
<td width="33%">
<p>Indicates the level at which the option resides and the name of the option must be specified, when manipulating socket options.</p>
</td>
</tr>
<tr>
<td width="47%">
<p>optName</p>
</td>
<td width="33%">
<p>Indicates the Optname options which are passed uninterpreted to system interface.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="47%">
<p>optLen</p>
</td>
<td width="33%">
<p>Indicates the option length obtained by invoking the FtGetSockOpt API.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="47%">
<p>optValue</p>
</td>
<td width="33%">
<p>Indicates the option value obtained by invoking the FtGetSockOpt API.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="47%">
<p>FILLP_INT</p>
</td>
<td width="33%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束&crarr;</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证optValue、optLen的地址有效，同时保证*optLen长度的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>在windows平台上，IP_TOS设置受windows接口限制，只能被设置为0x00 0x20 0xA0 0xE0，如果设置为其他值也会调整为上述相应值，使用FtGetSockOpt接口会获取到调整之后的值；</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000104"></a>1.3.4.2 FtSetSockOpt</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtSetSockOpt(FILLP_INT fd, FILLP_INT level, FILLP_INT optName,</p>
<p>void *optValue, FILLP_INT optLen);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the Fillp Adapter to set socket options.</p>
</td>
</tr>
<tr>
<td rowspan="5" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by FtSocket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>level</p>
</td>
<td width="40%">
<p>Indicates the level at which the option resides and the name of the option must be specified, when manipulating socket options.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>optName</p>
</td>
<td width="40%">
<p>Indicates the Optname options which are passed uninterpreted to system interface.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>optValue</p>
</td>
<td width="40%">
<p>Indicates the option value obtained by invoking the FtSetSockOpt API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>optLen</p>
</td>
<td width="40%">
<p>Indicates the option length obtained by invoking the FtSetSockOpt API.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证optValue的地址有效，同时保证optLen长度的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>在windows平台上，IP_TOS设置受windows接口限制，只能被设置为0x00 0x20 0xA0 0xE0，如果设置为其他值也会调整为上述相应值。</p>
<p>在windows平台上，设置IP_TOS之后，需要收发两端建链之后，IP_TOS才生效，建链报文IP_TOS是未生效的。</p>
<p>不支持多线程调用。</p>
<p>使用opt 类型FILLP_SOCK_MP_REG_ENCRYPT_CB注册多径加解密回调时 ，需要在建链后调用，即发端FtConnect/收端FtAccept成功后调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000105"></a>1.3.4.3 FtGetSockName</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型</p>
</td>
<td colspan="2" width="66%">
<p>FILLP_INT FtGetSockName(FILLP_INT fd, FILLP_SOCKADDR *name, socklen_t *nameLen);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能</p>
</td>
<td colspan="2" width="66%">
<p>This function is called by the FillP adapter to get the address with which the requested socket is bound.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>fd</p>
</td>
<td width="33%">
<p>Indicates the socket created.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>nameLen</p>
</td>
<td width="33%">
<p>Indicates the length of the address.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>name</p>
</td>
<td width="33%">
<p>Indicates the socket address that needs to be connected.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_INT</p>
</td>
<td width="33%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>由调用者保证name、nameLen的地址有效，同时保证*nameLen的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000106"></a>1.3.4.4 FtGetPeerName</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtGetPeerName(FILLP_INT fd, FILLP_SOCKADDR *name, socklen_t *nameLen);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the Fillp adapter to get the peer address to which the requested socket is connected.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates the socket created.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>nameLen</p>
</td>
<td width="40%">
<p>Indicates the length of the address.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>name</p>
</td>
<td width="40%">
<p>Indicates the socket address that needs to be connected.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证name、nameLen的地址有效，同时保证*nameLen的内存可访问。不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000107"></a>1.3.4.5 FtFcntl</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtFcntl(FILLP_INT fd, FILLP_INT cmd, FILLP_INT val);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is used to manipulate the file descriptor.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>cmd</p>
</td>
<td width="40%">
<p>Indicates the command to perform on the socket s.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>val</p>
</td>
<td width="40%">
<p>Indicates the flag value used to set the blocking and non blocking socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000108"></a>1.3.4.6 FtIoctl</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtIoctl(FILLP_INT fd, FILLP_ULONG cmd, FILLP_CONST FILLP_INT *val);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function controls the I/O mode of a socket.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>cmd</p>
</td>
<td width="40%">
<p>Indicates the command to perform on the socket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>val</p>
</td>
<td width="40%">
<p>Indicates the flag value used to set the blocking and non blocking socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证val的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000109"></a>1.3.4.7 FtIoctlSocket</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtIoctlSocket(FILLP_INT fd, FILLP_SLONG cmd, FILLP_CONST FILLP_INT *val);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function controls the I/O mode of a socket.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>cmd</p>
</td>
<td width="40%">
<p>Indicates the command to perform on the socket.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>val</p>
</td>
<td width="40%">
<p>Indicates the flag value used to set the blocking and non blocking socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证val的地址有效，不正确的参数会导致内存访问错误。</p>
<p>该接口仅适用于windows平台。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000110"></a>1.3.5 事件回调接口</h3>
<h4><a name="_Toc256000111"></a>1.3.5.1 FtApiRegEventCallbackFunc</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtApiRegEventCallbackFunc(FILLP_INT fd, FILLP_CONST FillpEvtCbkFunc evtCbkFunc);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Register the event callback function on the socket.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>evtCbkFunc</p>
</td>
<td width="40%">
<p>Pointer to event callback function FillpEvtCbkFunc.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证evtCbkFunc为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型</p>
</td>
<td colspan="2" width="66%">
<p>typedef FILLP_INT (*FillpEvtCbkFunc)(FILLP_INT fd, FtEventCbkInfo *info);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能</p>
</td>
<td colspan="2" width="66%">
<p>This callback is used to&nbsp; notify APP when some events occur.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>fd</p>
</td>
<td width="33%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>info</p>
</td>
<td width="33%">
<p>Pointer to event callback information FtEventCbkInfo.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_INT</p>
</td>
<td width="33%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>typedef enum {</p>
<p>FT_EVT_FRAME_STATS,</p>
<p>FT_EVT_TRAFFIC_DATA,</p>
<p>FT_EVT_MAX,</p>
<p>} FtEnumEventType;</p>
<p>/**</p>
<p>* Structure of event callback information.</p>
<p>*/</p>
<p>typedef struct {</p>
<p>FtEnumEventType evt;</p>
<p>union {</p>
<p>FillpFrameSendStats frameSendStats; /* with FT_EVT_FRAME_SENT */</p>
<p>FillpTrafficInfo trafficData;/* with FT_EVT_TRAFFIC_DATA*/</p>
<p>FILLP_UINT32 reserved;</p>
<p>} info;</p>
<p>} FtEventCbkInfo;</p>
<p>evt：事件类型</p>
<p>info：事件信息</p>
<p>typedef struct {</p>
<p>FILLP_INT32 bwStat;</p>
<p>FILLP_UINT32 rate; /* kbps */</p>
<p>} FillpBwInfo;</p>
<p>bwStat：带宽状态</p>
<p>rate：速率</p>
<p>/**</p>
<p>* Structure of jitter information.</p>
<p>*/</p>
<p>typedef struct {</p>
<p>FILLP_UINT8 jitterLevel; /* range: 0~15 */</p>
<p>FILLP_UINT32 bufferTime; /* ms */</p>
<p>} FillpJitterInfo;</p>
<p>typedef struct {</p>
<p>FILLP_UINT32 queueUsage;</p>
<p>FILLP_UINT32 cachedFrameCnt;</p>
<p>} FillpFramePcbInfo;</p>
<p>/**</p>
<p>* Structure of frame/slice sent info.</p>
<p>*/</p>
<p>typedef struct {</p>
<p>FILLP_INT32 seq;</p>
<p>FILLP_INT32 level;</p>
<p>FILLP_INT32 subSeqNum;</p>
<p>FILLP_INT32 status;</p>
<p>FILLP_UINT32 interval;</p>
<p>FillpFramePcbInfo pcbStat;</p>
<p>} FillpFrameSentInfo;</p>
<p>#define FILLP_TRAFFIC_LEN 32</p>
<p>typedef struct {</p>
<p>FILLP_UCHAR stats[FILLP_TRAFFIC_LEN];</p>
<p>} FillpTrafficInfo;</p>
<p>流量统计信息，里面的内容提供给软总线组网模块使用，调用者不需要知道信息的确切含义。</p>
<p>typedef struct {</p>
<p>FILLP_INT qosState;</p>
<p>FILLP_INT meanRtt;</p>
<p>FILLP_INT bwStat;</p>
<p>} FillpQosInfo;</p>
<p>多径主链路QOS状态信息，提供给软总线组网模块使用。</p>
<p>#define FILLP_MP_DFX_STR_LEN 64</p>
<p>typedef struct {</p>
<p>FILLP_INT mpRatio; /* time ratio of mp enabled in the whole session */</p>
<p>FILLP_CHAR subPathRatio[FILLP_MP_DFX_STR_LEN]; /* contribution of the secondary flow */</p>
<p>FILLP_INT averageFrameDelayDecreased; /* absolute frame delay gain when mp is enabled */</p>
<p>FILLP_CHAR mpStatus[FILLP_MP_DFX_STR_LEN]; /* counts or reason of mp enabled or mp disabled event */</p>
<p>FILLP_CHAR errorInfo[FILLP_MP_DFX_STR_LEN]; /* counts of each error */</p>
<p>FILLP_CHAR *extend; /* not used now, just for extension */</p>
<p>} FillpMpDfxInfo;</p>
<p>多径MP DFX信息，提供给软总线DFX模块使用。</p>
<p>typedef struct {</p>
<p>FILLP_UINT seq;</p>
<p>FILLP_UINT frameRtt;</p>
<p>FILLP_UINT rtt;</p>
<p>FILLP_UINT recvCost;</p>
<p>} FillpFrameRttInfo;</p>
<p>帧延时统计信息</p>
<h4><a name="_Toc256000112"></a>1.3.5.2 FtApiUnregEventCallbackFunc</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtApiUnregEventCallbackFunc(FILLP_INT fd, FILLP_CONST FillpEvtCbkFunc evtCbkFunc);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Unregister the event callback function on the socket.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>evtCbkFunc</p>
</td>
<td width="40%">
<p>Pointer to event callback function FillpEvtCbkFunc.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证evtCbkFunc为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000113"></a>1.3.5.3 FtApiEventInfoGet</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtApiEventInfoGet(FILLP_INT fd, FtEventCbkInfo *info);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Get the event info on the socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates a socket created by the FtSocket API.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>info</p>
</td>
<td width="40%">
<p>info-&gt;evt (IN):&nbsp; Indicates the event type.</p>
<p>info-&gt;info(OUT):&nbsp; Indicates the event info according to the event type.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证info的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000116"></a>1.3.6 日志接口</h3>
<h4><a name="_Toc256000117"></a>1.3.6.1 FillpApiSetDebugLogLevel</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FillpApiSetDebugLogLevel(FILLP_UINT8 logLevel);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Sets the debug log level.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>logLevel</p>
</td>
<td width="40%">
<p>Defines the log level.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000118"></a>1.3.6.2 FillpApiConfigLogModules</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型</p>
</td>
<td colspan="2" width="66%">
<p>FILLP_UINT32 FillpApiConfigLogModules(FILLP_ULLONG logModules);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能</p>
</td>
<td colspan="2" width="66%">
<p>Sets the log enable/disable status for different modules.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>logModules&crarr;</p>
</td>
<td width="33%">
<p>The values of all the modules for which log needs to be enabled. If set to 0xFFFFFFFF, then it is enabled for all the modules.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_UINT32</p>
</td>
<td width="33%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000119"></a>1.3.7 dfx接口</h3>
<h4><a name="_Toc256000120"></a>1.3.7.1 FtStartTrace</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>FILLP_INT32 FtStartTrace(FILLP_UINT8 traceObjType, FILLP_INT traceObj,</p>
<p>FILLP_CONST void *traceHandle);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能&crarr;</p>
</td>
<td colspan="2" width="66%">
<p>This function is called by the FillP adapter to start the trace of user APIs and network messages for a particular socket.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>traceObjType</p>
</td>
<td width="33%">
<p>Indicates a trace object defined in FILLP_TRACE_OBJ_TYPE_ENUM and indicates the type of trace which must be done.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>traceObj</p>
</td>
<td width="33%">
<p>A user must pass the FtSocket identification to set the trace for that particular socket (0xFFFFFFFF - means for all the sockets).</p>
</td>
</tr>
<tr>
<td width="33%">
<p>traceHandle</p>
</td>
<td width="33%">
<p>Provides a trace handle which is transparently passed to the user while giving trace. 0xFFFFFFFF is an invalid handle.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_INT32</p>
</td>
<td width="33%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>由调用者保证traceHandle的地址有效，协议栈在回调时传回给业务，内部不会读取该地址内容。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000121"></a>1.3.7.2 FtStopTrace</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FtStopTrace(FILLP_UINT8 traceObjType, FILLP_INT traceObj);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the FillP adapter to stop the trace for a particular socket.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>traceObjType</p>
</td>
<td width="40%">
<p>Indicates a trace object as defined in FILLP_TRACE_OBJ_TYPE_ENUM&nbsp; and tells what kind of trace should be done.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>&nbsp;</p>
</td>
<td width="40%">
<p>traceObj</p>
</td>
<td width="40%">
<p>This is for a particular socket or for all the associations (0xFFFFFFFF).</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000122"></a>1.3.7.3 FtRegTraceCallbackFn</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FtRegTraceCallbackFn(FILLP_CONST FillpTraceSend traceFuncCallback);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Registers the callback function for FillP message trace and FillP command trace.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>traceFuncCallback</p>
</td>
<td width="40%">
<p>Indicates a trace callback.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证traceFuncCallback为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>typedef void (*FillpTraceSend)(FILLP_UINT32 traceObjType, void *traceHandle,</p>
<p>FILLP_UINT32 msgLength, FILLP_UINT32 traceObj, FILLP_UINT8 *traceDescript,</p>
<p>FILLP_CHAR *traceMsg, ...);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This callback function is used to call the application trace function.</p>
</td>
</tr>
<tr>
<td rowspan="6" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>traceObjType</p>
</td>
<td width="40%">
<p>Indicates a trace object of type FillpTraceTypeEnum.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>traceHandle</p>
</td>
<td width="40%">
<p>Indicates the handle passed by application.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>msgLength</p>
</td>
<td width="40%">
<p>Indicates the length of the message.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>traceObj</p>
</td>
<td width="40%">
<p>Indicates the socket identifier for which the trace is currently provided.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>traceDescript</p>
</td>
<td width="40%">
<p>Indicates the structure FillpTraceDescriptSt.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>traceMsg</p>
</td>
<td width="40%">
<p>Indicates the actual trace message. For commands from user, only the arguments are part of the indication. For network messages, the FillP header along with the IP header (port and IP) are given as part of indication.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>typedef enum FillpTraceTypeEnum {</p>
<p>FILLP_TRACE_DIRECT_DISABLE = 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Indicates that FillP/VTP trace is disabled. */</p>
<p>FILLP_TRACE_DIRECT_USER,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Indicates that FillP will trace all the user commands (socket API). */</p>
<p>FILLP_TRACE_DIRECT_NETWORK,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Indicates whether FillP packets are sent or received. */</p>
<p>FILLP_TRACE_DIRECT_USER_NETWORK_ENABLE, /* Enables FillP to send or receive packets. */</p>
<p>FILLP_TRACE_END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Indicates the FillP/VTP trace type enum end.&nbsp; */</p>
<p>} FillpTraceTypeEn;</p>
<h4><a name="_Toc256000123"></a>1.3.7.4 FillpDebugControl</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>void FillpDebugControl(FILLP_UINT8 command, FILLP_CONST void *content);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>FillP uses this function to control the debug command options. You can call this API and set the debug level.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>command</p>
</td>
<td width="40%">
<p>Indicates the debug command type of any value from FillpDebugCmdEn</p>
</td>
</tr>
<tr>
<td width="40%">
<p>content</p>
</td>
<td width="40%">
<p>Indicates debug control parameter.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证content的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000124"></a>1.3.7.5 FillpRegLMCallbackFn</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FillpRegLMCallbackFn(FILLP_CONST FillpLmCallbackFunc *lmFuncCallback);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the FillP adapter to register the adapter's callback function for LM functionality. If A function pointer is passed as NULL, then it is omitted&nbsp; for copying. So, the user/adapter can call this function to register the function pointers separately.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>lmFuncCallback</p>
</td>
<td width="40%">
<p>Indicates the pointer to LM callback function struct.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证lmFuncCallback为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>typedef struct {</p>
<p>FillpDebugSendFunc debugCallbackFunc; /* Registers debug information output callback function. */</p>
<p>} FillpLmCallbackFunc;</p>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>typedef void (*FillpDebugSendFunc)(FILLP_UINT32 debugType, FILLP_UINT32 debugLvl,</p>
<p>FILLP_UINT32 debugId, FILLP_CHAR *format, ...);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This callback is use for debug send.</p>
</td>
</tr>
<tr>
<td rowspan="4" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>debugType</p>
</td>
<td width="40%">
<p>Debug type.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>debugLvl</p>
</td>
<td width="40%">
<p>Debug level.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>debugId</p>
</td>
<td width="40%">
<p>Indicates the file and line information.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>format</p>
</td>
<td width="40%">
<p>Specifies the actual message.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000125"></a>1.3.7.6 FtFillpStatsGet</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtFillpStatsGet(FILLP_INT fd, struct FillpStatisticsPcb *outStats);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the fillp Adapter to get the statistics information for a each type.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates the socket index for which stats need to be provided.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>outStats</p>
</td>
<td width="40%">
<p>Indicates fillp_statistics_pc, to which statistics are copied.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证outStats的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000126"></a>1.3.7.7 FtFillpStatShow</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtFillpStatShow(FILLP_UINT32 fillpStatsType, FILLP_INT fd);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called by the FillP adapter to to show the statistics information.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>fillpStatsType</p>
</td>
<td width="40%">
<p>Indicates the statistics type.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>fd</p>
</td>
<td width="40%">
<p>Indicates the socket index.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000127"></a>1.3.7.8 FtSetDfxEventCb</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtSetDfxEventCb(void *softObj, FillpDfxEventCb evtCb);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>register hisysevent dfx event callback function.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>softObj</p>
</td>
<td width="40%">
<p>any usefull message to evtCb.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>evtCb</p>
</td>
<td width="40%">
<p>event callback function</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证evtCb为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000128"></a>1.3.7.9 FtDfxHiDumper</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtDfxHiDumper(FILLP_UINT32 argc, const FILLP_CHAR **argv, void *softObj, FillpDfxDumpFunc dump);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>deal with HiDumper cmd.</p>
</td>
</tr>
<tr>
<td rowspan="4" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>argc</p>
</td>
<td width="40%">
<p>count of hidumper args</p>
</td>
</tr>
<tr>
<td width="40%">
<p>argv</p>
</td>
<td width="40%">
<p>value of hidumper args</p>
</td>
</tr>
<tr>
<td width="40%">
<p>softObj</p>
</td>
<td width="40%">
<p>any usefull message to evtCb.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>dump</p>
</td>
<td width="40%">
<p>function to printf data</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证dump函数指针有效，不正确的函数指针会导致不可预料的后果；</p>
<p>由调用者保证argc值与argv个数匹配，且argv指针数组中指向的地址内容有效，不正确的参数将导致不可预料的后果。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000129"></a>1.3.8 config接口</h3>
<h4><a name="_Toc256000130"></a>1.3.8.1 FtConfigGet</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FtConfigGet(FILLP_UINT32 name, void *value, FILLP_CONST void *param);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Gets individual FillP stack configuration items.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>name</p>
</td>
<td width="40%">
<p>Specifies the name of the configuration item to configure (FILLP_CONFIG_LIST enum).</p>
</td>
</tr>
<tr>
<td width="40%">
<p>param</p>
</td>
<td width="40%">
<p>Contains the value for the configuration item, which requires additional information to config.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>value</p>
</td>
<td width="40%">
<p>Contains the value for the configuration item.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证value、param的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000131"></a>1.3.8.2 FtConfigSet</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FtConfigSet(FILLP_UINT32 name, FILLP_CONST void *value,</p>
<p>FILLP_CONST void *param);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Sets individual FillP stack configuration items.</p>
</td>
</tr>
<tr>
<td rowspan="3" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>name</p>
</td>
<td width="40%">
<p>Indicates the name of the configuration item to configure.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>value</p>
</td>
<td width="40%">
<p>Contains the value for the configuration item.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>param</p>
</td>
<td width="40%">
<p>Contains the value for the configuration item, which requires additional information to configure.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, return the error code.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证value、param的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000132"></a>1.3.9 其他接口</h3>
<h4><a name="_Toc256000133"></a>1.3.9.1 FillpApiRegLibSysFunc</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT32 FillpApiRegLibSysFunc(FILLP_CONST FillpSysLibCallbackFuncSt *libSysFunc,</p>
<p>FILLP_CONST void *para);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Registers the system interface functions to be used by the FillP stack. The function pointers of all system functions defined by this API are passed FillpSysLibCallbackFuncSt to FILLP stack to be registered and used during the run time of the stack. Users must pass "FillpCryptoRandFunc cryptoRand" which is to register cryptographically strong random number generator function. Others callback pointers are optional, if users pass them as NULL, then default functions will be registered by FillP/VTP. This function should be called before initializing the stack.</p>
</td>
</tr>
<tr>
<td rowspan="2" width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>libSysFunc</p>
</td>
<td width="40%">
<p>Pointer to system interface callback function structure FillpSysLibCallbackFuncSt.</p>
</td>
</tr>
<tr>
<td width="40%">
<p>para</p>
</td>
<td width="40%">
<p>This is a reserve parameter for future extension. User can pass it as FILLP_NULL_PTR.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT32</p>
</td>
<td width="40%">
<p>On success, zero is returned.</p>
<p>On error, -1 is returned, and errno is set to indicate the error.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>由调用者保证libSysFunc为正确的函数指针，不正确的函数指针会导致不可预料的后果。</p>
<p>由调用者保证para的地址有效，不正确的参数会导致内存访问错误。</p>
<p>不支持多线程调用。</p>
<p>不支持部分注册。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>libSysFunc内容太多，详见头文件注释。</p>
<h4><a name="_Toc256000134"></a>1.3.9.2 FtGetErrno</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_INT FtGetErrno();</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function gives the error values. If any FillP API fails, then there will be errno set by FillP/VTP.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_INT</p>
</td>
<td width="40%">
<p>Return the errno.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000135"></a>1.3.9.3 FtGetRtt</h4>
<table width="529">
<tbody>
<tr>
<td width="33%">
<p>函数原型</p>
</td>
<td colspan="2" width="66%">
<p>FILLP_ULLONG FtGetRtt(FILLP_INT fd);</p>
</td>
</tr>
<tr>
<td width="33%">
<p>函数功能</p>
</td>
<td colspan="2" width="66%">
<p>Returns rtt in microseconds which was calculated while setting up the connection for the sockFd socket.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（IN）</p>
</td>
<td width="33%">
<p>fd</p>
</td>
<td width="33%">
<p>Indicates the socket index.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（INOUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>参数（OUT）</p>
</td>
<td width="33%">
<p>None</p>
</td>
<td width="33%">
<p>-</p>
</td>
</tr>
<tr>
<td width="33%">
<p>返回值</p>
</td>
<td width="33%">
<p>FILLP_ULLONG</p>
</td>
<td width="33%">
<p>On success, return calculated rtt value as a unsigned long long value.</p>
<p>On error, return FILLP_NULL.</p>
</td>
</tr>
<tr>
<td width="33%">
<p>使用约束</p>
</td>
<td colspan="2" width="66%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000136"></a>1.3.9.4 FtGetStackTime</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_ULLONG FtGetStackTime(FILLP_INT instIndex);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>This function is called to get the current stack time in FillP/VTP.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>instIndex</p>
</td>
<td width="40%">
<p>Indicates the instance index to check.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_ULLONG</p>
</td>
<td width="40%">
<p>Last time updated of stack.</p>
<p>On success, return the last time updated of stack.</p>
<p>On error, return FILLP_NULL</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4><a name="_Toc256000137"></a>1.3.9.5 FtGetVersion</h4>
<table width="529">
<tbody>
<tr>
<td width="20%">
<p>函数原型</p>
</td>
<td colspan="2" width="80%">
<p>FILLP_CHAR_PTR FtGetVersion(void);</p>
</td>
</tr>
<tr>
<td width="20%">
<p>函数功能</p>
</td>
<td colspan="2" width="80%">
<p>Gets the FillP version string.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（IN）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（INOUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>参数（OUT）</p>
</td>
<td width="40%">
<p>None</p>
</td>
<td width="40%">
<p>-</p>
</td>
</tr>
<tr>
<td width="20%">
<p>返回值</p>
</td>
<td width="40%">
<p>FILLP_CHAR_PTR</p>
</td>
<td width="40%">
<p>Return the version string.</p>
</td>
</tr>
<tr>
<td width="20%">
<p>使用约束</p>
</td>
<td colspan="2" width="80%">
<p>不支持多线程调用。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3><a name="_Toc256000152"></a>1.3.10 交互流程</h3>

![](figures/Stream_transfer_processes.png)